softdb:

1.unchanged code block's border:
version_set{
    LogNumber()
    PrevLogNumber()
    MarkFileNumberUsed(logs[i])
    LastSequence()
    SetLastSequence(max_sequence)
    NewFileNumber()
}


2.changed code block's border:
db_impl{

    (write) MakeRoomForWrite(my_batch == nullptr)

    (get)(in write's MakeRoomForWrite)(open) MaybeScheduleCompaction()------>env_->Schedule(&DBImpl::BGWork, this);
                                         BGWork----->BackgroundCall()
                                         BackgroundCall()------>BackgroundCompaction() / MaybeScheduleCompaction()

       --BackgroundCompaction()------->CompactMemTable(), DoCompactionWork(), CleanupCompaction(), DeleteObsoleteFiles()


    (CompactMemTable) (RecoverLogFile) WriteLevel0Table()

    WriteLevel0Table(mem, edit, nullptr)-------->builder.cc's function: BuildTable(use dbformat's ExtractUserKey to
    extract user key from internal key)




    (open) (BackgroundCompaction) (CompactMemTable) DeleteObsoleteFiles()


}



3.keep the format of leveldb's data in DRAM, when transfer data from DRAM
into NVM, design the format on your own. for example, remove the sequence of
internal key and keep the key type, mark the time sequence on interval object,
which differs the new and old data on nvm when finding key on nvm.


4.in db_bench.cc's RunBenchmark() to test FLAGS_benchmarks in multi-thread





