softdb:

1.unchanged code block's border:
version_set{
    LogNumber()
    PrevLogNumber()
    MarkFileNumberUsed(logs[i])
    LastSequence()
    SetLastSequence(max_sequence)
    NewFileNumber()
}


2.changed code block's border:
db_impl{

    (write) MakeRoomForWrite(my_batch == nullptr)

    (get)(in write's MakeRoomForWrite)(open) MaybeScheduleCompaction()------>env_->Schedule(&DBImpl::BGWork, this);
                                         BGWork----->BackgroundCall()
                                         BackgroundCall()------>BackgroundCompaction() / MaybeScheduleCompaction()

       --BackgroundCompaction()------->CompactMemTable(), versions_->PickCompaction(),
                                       DoCompactionWork(), CleanupCompaction(), DeleteObsoleteFiles()


    (CompactMemTable) (RecoverLogFile) WriteLevel0Table()

    WriteLevel0Table(mem, edit, nullptr)-------->builder.cc's function: BuildTable(use dbformat's ExtractUserKey to
    extract user key from internal key)


    **versions_->LogAndApply(edit, mutex_) to record information about db,
      currently edit.SetLogNumber() and edit.SetPreLogNumber() are needed.



    (open) (BackgroundCompaction) (CompactMemTable) DeleteObsoleteFiles()


}



3.keep the format of leveldb's data in DRAM, when transfer data from DRAM
    into NVM, design the format on your own.
    Mark the time sequence on interval object,
    which differs the new and old data on nvm when finding key on nvm.


4.in db_bench.cc's RunBenchmark() to test FLAGS_benchmarks in multi-thread



5.currently do not delete any code from levelDB except version_set/version_edit
    which will be totally different on nvm.


6.nvm_imm_ entry is in form of char, similar to imm_ entry.
    nvm_imm_ should be convenient for merging.
    iterator_wrapper.h and merger.cc are useful for merging nvm_imm_.


7.keep internalKey form to support snapshot.
    cuckoo hash can be a option to select, points to the fist user key in nvm_imm_,
    nvm_imm_ should be highly similar to imm_.

8.ISL needs dynamic merging_iterator(dynamic_merger.cc) to iterate involved nvm_imm_'s iterators.
    Then use merger.cc to merge dynamic_merger's result with the iterator of mem_ and imm_.
    (see DBImpl::NewInternalIterator and AddIterators)


9.When use cuckoo hash to locate the first user key at nvm_imm_,
    the repeat number(after locate the node_, times to call node_->next())
    should be less than skiplist search steps. If not, cuckoo hash's search
    result should not be used(offset set to < 0).











