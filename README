softdb:

1.unchanged code block's border:
version_set{
    LogNumber()
    PrevLogNumber()
    MarkFileNumberUsed(logs[i])
    LastSequence()
    SetLastSequence(max_sequence)
    NewFileNumber()
}


2.changed code block's border:
db_impl{

    (write) MakeRoomForWrite(my_batch == nullptr)

    (get)(in write's MakeRoomForWrite)(open) MaybeScheduleCompaction()------>env_->Schedule(&DBImpl::BGWork, this);
                                         BGWork----->BackgroundCall()
                                         BackgroundCall()------>BackgroundCompaction() / MaybeScheduleCompaction()

       --BackgroundCompaction()------->CompactMemTable(), versions_->PickCompaction(),
                                       DoCompactionWork(), CleanupCompaction(), DeleteObsoleteFiles()


    (CompactMemTable) (RecoverLogFile) WriteLevel0Table()

    WriteLevel0Table(mem, edit, nullptr)-------->builder.cc's function: BuildTable(use dbformat's ExtractUserKey to
    extract user key from internal key)


    **versions_->LogAndApply(edit, mutex_) to record information about db,
      currently edit.SetLogNumber() and edit.SetPreLogNumber() are needed.



    (open) (BackgroundCompaction) (CompactMemTable) DeleteObsoleteFiles()


}



3.keep the format of leveldb's data in DRAM, when transfer data from DRAM
    into NVM, design the format on your own.
    Mark the time sequence on interval object,
    which differs the new and old data on nvm when finding key on nvm.


4.in db_bench.cc's RunBenchmark() to test FLAGS_benchmarks in multi-thread



5.currently do not delete any code from levelDB except version_set/version_edit
    which will be totally different on nvm.


6.nvm_imm_ entry is in form of char, similar to imm_ entry.
    nvm_imm_ should be convenient for merging.
    iterator_wrapper.h and merger.cc are useful for merging nvm_imm_.


7.keep internalKey form to support snapshot.
    cuckoo hash can be a option to select, points to the fist user key in nvm_imm_,
    nvm_imm_ should be highly similar to imm_.

8.ISL needs dynamic merging_iterator(dynamic_merger.cc) to iterate involved nvm_imm_'s iterators.
    Then use merger.cc to merge dynamic_merger's result with the iterator of mem_ and imm_.
    (see DBImpl::NewInternalIterator and AddIterators)


9.When use cuckoo hash to locate the first user key at nvm_imm_,
    the repeat number(after locate the node_, times to call node_->next())
    should be less than skiplist Search steps. If not, cuckoo hash's Search
    result should not be used(offset set to < 0).

10.Set a threshold of merge operation, divide doesn't happen below it.
    If ISL is nearly full, pull this threshold up(X2), then there is less nvm_imm_ with larger size.

11.mutex_ guarantee thread safety of version_, we need to put another mutex(named nvm_mutex_)
    in ISL to guarantee its thread safety from compaction procedure of imm_ and nvm_imm_.
    Pass mutex_ into compaction procedure of nvm_imm_, lock it while modifying version_,
    unlock it otherwise, let nvm_mutex_ to protect nvm data.

12. Every nvm_index access(put or get) will update the
    most hot searchKey with its overlapped levels(intervals),
    merge procedure will focus on that hot key.

13. When iterate through database, create a snapshot to protect data from being deleted,
    after delete iterate, release this snapshot.

14. Use internal key to differentiate intervals, and use user key comparator to search intervals,
    therefore there is no merge split detailed problems.

15. be careful to use Slice = operation, as Slice b's pointer changes with Slice a, use Slice(String) instead

16.check .h include after all things done. check inline.

Record:
    1-1000000 no compact 3.8s softdb
    1-2000000 no compact 7.9s softdb
    1-1000000 compact 4.2s leveldb

    1-100000 compact 0.44s no compact 0.43 softdb
    1-100000 compact 0.47s leveldb

BreakThrough:
    When set write_buffer_size(4<<10)
    (2875 files generated including log file, indicating there
    will be nearly 1500 SSTs if no merge happened.)

    1-100000 no compact softdb:
        Phase1 nanosecond: 3432620848
        Phase2 nanosecond: 5790555944
        Phase3 nanosecond: 3086183199
        Total nanosecond: 12309384988

    1-100000 compact leveldb(block cache disabled):
        Phase1 nanosecond: 12703722663
        Phase2 nanosecond: 4163530551
        Phase3 nanosecond: 8580695135
        Total nanosecond: 25447959681

    1-100000 compact leveldb(block cache enabled): due to frequent block cache miss.
        Phase1 nanosecond: 11730493820
        Phase2 nanosecond: 4055176908
        Phase3 nanosecond: 21473116296
        Total nanosecond: 37258812023

    which means the more tables generated, the faster softdb is than leveldb.


imm_key's_count_:98073




cmake_minimum_required(VERSION 3.9)
project(leveldb VERSION 1.21.0 LANGUAGES C CXX)

# This project can use C11, but will gracefully decay down to C89.
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED OFF)
set(CMAKE_C_EXTENSIONS OFF)

# This project requires C++11.
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

option(LEVELDB_BUILD_TESTS "Build LevelDB's unit tests" ON)
option(LEVELDB_BUILD_BENCHMARKS "Build LevelDB's benchmarks" ON)
option(LEVELDB_INSTALL "Install LevelDB's header and library" ON)

include(TestBigEndian)
test_big_endian(LEVELDB_IS_BIG_ENDIAN)

include(CheckIncludeFile)
check_include_file("unistd.h" HAVE_UNISTD_H)

include(CheckLibraryExists)
check_library_exists(crc32c crc32c_value "" HAVE_CRC32C)
check_library_exists(snappy snappy_compress "" HAVE_SNAPPY)
check_library_exists(tcmalloc malloc "" HAVE_TCMALLOC)

include(CheckSymbolExists)
check_symbol_exists(fdatasync "unistd.h" HAVE_FDATASYNC)

include(CheckCXXSourceCompiles)

# Test whether -Wthread-safety is available. See
# https://clang.llvm.org/docs/ThreadSafetyAnalysis.html
# -Werror is necessary because unknown attributes only generate warnings.
set(OLD_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})
list(APPEND CMAKE_REQUIRED_FLAGS -Werror -Wthread-safety)
check_cxx_source_compiles("
struct __attribute__((lockable)) Lock {
  void Acquire() __attribute__((exclusive_lock_function()));
  void Release() __attribute__((unlock_function()));
};
struct ThreadSafeType {
  Lock lock_;
  int data_ __attribute__((guarded_by(lock_)));
};
int main() { return 0; }
"  HAVE_CLANG_THREAD_SAFETY)
set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})

# Test whether C++17 __has_include is available.
check_cxx_source_compiles("
#if defined(__has_include) &&  __has_include(<string>)
#include <string>
#endif
int main() { std::string str; return 0; }
" HAVE_CXX17_HAS_INCLUDE)

set(LEVELDB_PUBLIC_INCLUDE_DIR "include/leveldb")
set(LEVELDB_PORT_CONFIG_DIR "include/port")

configure_file(
  "${PROJECT_SOURCE_DIR}/port/port_config.h.in"
  "${PROJECT_BINARY_DIR}/${LEVELDB_PORT_CONFIG_DIR}/port_config.h"
)

include_directories(
  "${PROJECT_BINARY_DIR}/include"
  "${PROJECT_SOURCE_DIR}"
)

if(BUILD_SHARED_LIBS)
  # Only export LEVELDB_EXPORT symbols from the shared library.
  add_compile_options(-fvisibility=hidden)
endif(BUILD_SHARED_LIBS)

add_library(leveldb "")
target_sources(leveldb
  PRIVATE
    "${PROJECT_BINARY_DIR}/${LEVELDB_PORT_CONFIG_DIR}/port_config.h"
    "${PROJECT_SOURCE_DIR}/db/builder.cc"
    "${PROJECT_SOURCE_DIR}/db/builder.h"
    "${PROJECT_SOURCE_DIR}/db/c.cc"
    "${PROJECT_SOURCE_DIR}/db/db_impl.cc"
    "${PROJECT_SOURCE_DIR}/db/db_impl.h"
    "${PROJECT_SOURCE_DIR}/db/db_iter.cc"
    "${PROJECT_SOURCE_DIR}/db/db_iter.h"
    "${PROJECT_SOURCE_DIR}/db/dbformat.cc"
    "${PROJECT_SOURCE_DIR}/db/dbformat.h"
    "${PROJECT_SOURCE_DIR}/db/dumpfile.cc"
    "${PROJECT_SOURCE_DIR}/db/filename.cc"
    "${PROJECT_SOURCE_DIR}/db/filename.h"
    "${PROJECT_SOURCE_DIR}/db/log_format.h"
    "${PROJECT_SOURCE_DIR}/db/log_reader.cc"
    "${PROJECT_SOURCE_DIR}/db/log_reader.h"
    "${PROJECT_SOURCE_DIR}/db/log_writer.cc"
    "${PROJECT_SOURCE_DIR}/db/log_writer.h"
    "${PROJECT_SOURCE_DIR}/db/memtable.cc"
    "${PROJECT_SOURCE_DIR}/db/memtable.h"
    "${PROJECT_SOURCE_DIR}/db/repair.cc"
    "${PROJECT_SOURCE_DIR}/db/skiplist.h"
    "${PROJECT_SOURCE_DIR}/db/snapshot.h"
    "${PROJECT_SOURCE_DIR}/db/table_cache.cc"
    "${PROJECT_SOURCE_DIR}/db/table_cache.h"
    "${PROJECT_SOURCE_DIR}/db/version_edit.cc"
    "${PROJECT_SOURCE_DIR}/db/version_edit.h"
    "${PROJECT_SOURCE_DIR}/db/version_set.cc"
    "${PROJECT_SOURCE_DIR}/db/version_set.h"
    "${PROJECT_SOURCE_DIR}/db/write_batch_internal.h"
    "${PROJECT_SOURCE_DIR}/db/write_batch.cc"
    "${PROJECT_SOURCE_DIR}/port/atomic_pointer.h"
    "${PROJECT_SOURCE_DIR}/port/port_stdcxx.h"
    "${PROJECT_SOURCE_DIR}/port/port.h"
    "${PROJECT_SOURCE_DIR}/port/thread_annotations.h"
    "${PROJECT_SOURCE_DIR}/table/block_builder.cc"
    "${PROJECT_SOURCE_DIR}/table/block_builder.h"
    "${PROJECT_SOURCE_DIR}/table/block.cc"
    "${PROJECT_SOURCE_DIR}/table/block.h"
    "${PROJECT_SOURCE_DIR}/table/filter_block.cc"
    "${PROJECT_SOURCE_DIR}/table/filter_block.h"
    "${PROJECT_SOURCE_DIR}/table/format.cc"
    "${PROJECT_SOURCE_DIR}/table/format.h"
    "${PROJECT_SOURCE_DIR}/table/iterator_wrapper.h"
    "${PROJECT_SOURCE_DIR}/table/iterator.cc"
    "${PROJECT_SOURCE_DIR}/table/merger.cc"
    "${PROJECT_SOURCE_DIR}/table/merger.h"
    "${PROJECT_SOURCE_DIR}/table/table_builder.cc"
    "${PROJECT_SOURCE_DIR}/table/table.cc"
    "${PROJECT_SOURCE_DIR}/table/two_level_iterator.cc"
    "${PROJECT_SOURCE_DIR}/table/two_level_iterator.h"
    "${PROJECT_SOURCE_DIR}/util/arena.cc"
    "${PROJECT_SOURCE_DIR}/util/arena.h"
    "${PROJECT_SOURCE_DIR}/util/bloom.cc"
    "${PROJECT_SOURCE_DIR}/util/cache.cc"
    "${PROJECT_SOURCE_DIR}/util/coding.cc"
    "${PROJECT_SOURCE_DIR}/util/coding.h"
    "${PROJECT_SOURCE_DIR}/util/comparator.cc"
    "${PROJECT_SOURCE_DIR}/util/crc32c.cc"
    "${PROJECT_SOURCE_DIR}/util/crc32c.h"
    "${PROJECT_SOURCE_DIR}/util/env.cc"
    "${PROJECT_SOURCE_DIR}/util/filter_policy.cc"
    "${PROJECT_SOURCE_DIR}/util/hash.cc"
    "${PROJECT_SOURCE_DIR}/util/hash.h"
    "${PROJECT_SOURCE_DIR}/util/logging.cc"
    "${PROJECT_SOURCE_DIR}/util/logging.h"
    "${PROJECT_SOURCE_DIR}/util/mutexlock.h"
    "${PROJECT_SOURCE_DIR}/util/no_destructor.h"
    "${PROJECT_SOURCE_DIR}/util/options.cc"
    "${PROJECT_SOURCE_DIR}/util/random.h"
    "${PROJECT_SOURCE_DIR}/util/status.cc"

  # Only CMake 3.3+ supports PUBLIC sources in targets exported by "install".
  $<$<VERSION_GREATER:CMAKE_VERSION,3.2>:PUBLIC>
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/c.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/cache.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/comparator.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/db.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/dumpfile.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/env.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/export.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/filter_policy.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/iterator.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/options.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/slice.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/status.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/table_builder.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/table.h"
    "${LEVELDB_PUBLIC_INCLUDE_DIR}/write_batch.h"
)

# POSIX code is specified separately so we can leave it out in the future.
target_sources(leveldb
  PRIVATE
    "${PROJECT_SOURCE_DIR}/util/env_posix.cc"
    "${PROJECT_SOURCE_DIR}/util/posix_logger.h"
)

# MemEnv is not part of the interface and could be pulled to a separate library.
target_sources(leveldb
  PRIVATE
    "${PROJECT_SOURCE_DIR}/helpers/memenv/memenv.cc"
    "${PROJECT_SOURCE_DIR}/helpers/memenv/memenv.h"
)

target_include_directories(leveldb
  PUBLIC
    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)
target_compile_definitions(leveldb
  PRIVATE
    # Used by include/export.h when building shared libraries.
    LEVELDB_COMPILE_LIBRARY
    # Used by port/port.h.
    LEVELDB_PLATFORM_POSIX=1
)
if (NOT HAVE_CXX17_HAS_INCLUDE)
  target_compile_definitions(leveldb
    PRIVATE
      LEVELDB_HAS_PORT_CONFIG_H=1
  )
endif(NOT HAVE_CXX17_HAS_INCLUDE)

if(BUILD_SHARED_LIBS)
  target_compile_definitions(leveldb
    PUBLIC
      # Used by include/export.h.
      LEVELDB_SHARED_LIBRARY
  )
endif(BUILD_SHARED_LIBS)

if(HAVE_CLANG_THREAD_SAFETY)
  target_compile_options(leveldb
    PUBLIC
      -Werror -Wthread-safety)
endif(HAVE_CLANG_THREAD_SAFETY)

if(HAVE_CRC32C)
  target_link_libraries(leveldb crc32c)
endif(HAVE_CRC32C)
if(HAVE_SNAPPY)
  target_link_libraries(leveldb snappy)
endif(HAVE_SNAPPY)
if(HAVE_TCMALLOC)
  target_link_libraries(leveldb tcmalloc)
endif(HAVE_TCMALLOC)

# Needed by port_stdcxx.h
find_package(Threads REQUIRED)
target_link_libraries(leveldb Threads::Threads)

add_executable(leveldbutil
  "${PROJECT_SOURCE_DIR}/db/leveldbutil.cc"
)
target_link_libraries(leveldbutil leveldb)

if(LEVELDB_BUILD_TESTS)
  enable_testing()

  function(leveldb_test test_file)
    get_filename_component(test_target_name "${test_file}" NAME_WE)

    add_executable("${test_target_name}" "")
    target_sources("${test_target_name}"
      PRIVATE
        "${PROJECT_BINARY_DIR}/${LEVELDB_PORT_CONFIG_DIR}/port_config.h"
        "${PROJECT_SOURCE_DIR}/util/testharness.cc"
        "${PROJECT_SOURCE_DIR}/util/testharness.h"
        "${PROJECT_SOURCE_DIR}/util/testutil.cc"
        "${PROJECT_SOURCE_DIR}/util/testutil.h"

        "${test_file}"
    )
    target_link_libraries("${test_target_name}" leveldb)
    target_compile_definitions("${test_target_name}"
      PRIVATE
        LEVELDB_PLATFORM_POSIX=1
    )
    if (NOT HAVE_CXX17_HAS_INCLUDE)
      target_compile_definitions("${test_target_name}"
        PRIVATE
          LEVELDB_HAS_PORT_CONFIG_H=1
      )
    endif(NOT HAVE_CXX17_HAS_INCLUDE)

    add_test(NAME "${test_target_name}" COMMAND "${test_target_name}")
  endfunction(leveldb_test)

  leveldb_test("${PROJECT_SOURCE_DIR}/db/c_test.c")
  leveldb_test("${PROJECT_SOURCE_DIR}/db/fault_injection_test.cc")

  leveldb_test("${PROJECT_SOURCE_DIR}/issues/issue178_test.cc")
  leveldb_test("${PROJECT_SOURCE_DIR}/issues/issue200_test.cc")

  leveldb_test("${PROJECT_SOURCE_DIR}/util/env_test.cc")
  leveldb_test("${PROJECT_SOURCE_DIR}/util/status_test.cc")
  leveldb_test("${PROJECT_SOURCE_DIR}/util/no_destructor_test.cc")

  if(NOT BUILD_SHARED_LIBS)
    leveldb_test("${PROJECT_SOURCE_DIR}/db/autocompact_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/corruption_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/db_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/dbformat_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/filename_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/log_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/recovery_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/skiplist_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/version_edit_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/version_set_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/db/write_batch_test.cc")

    leveldb_test("${PROJECT_SOURCE_DIR}/helpers/memenv/memenv_test.cc")

    leveldb_test("${PROJECT_SOURCE_DIR}/table/filter_block_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/table/table_test.cc")

    leveldb_test("${PROJECT_SOURCE_DIR}/util/arena_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/util/bloom_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/util/cache_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/util/coding_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/util/crc32c_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/util/hash_test.cc")
    leveldb_test("${PROJECT_SOURCE_DIR}/util/logging_test.cc")

    # TODO(costan): This test also uses
    #               "${PROJECT_SOURCE_DIR}/util/env_posix_test_helper.h"
    leveldb_test("${PROJECT_SOURCE_DIR}/util/env_posix_test.cc")
  endif(NOT BUILD_SHARED_LIBS)
endif(LEVELDB_BUILD_TESTS)

if(LEVELDB_BUILD_BENCHMARKS)
  function(leveldb_benchmark bench_file)
    get_filename_component(bench_target_name "${bench_file}" NAME_WE)

    add_executable("${bench_target_name}" "")
    target_sources("${bench_target_name}"
      PRIVATE
        "${PROJECT_BINARY_DIR}/${LEVELDB_PORT_CONFIG_DIR}/port_config.h"
        "${PROJECT_SOURCE_DIR}/util/histogram.cc"
        "${PROJECT_SOURCE_DIR}/util/histogram.h"
        "${PROJECT_SOURCE_DIR}/util/testharness.cc"
        "${PROJECT_SOURCE_DIR}/util/testharness.h"
        "${PROJECT_SOURCE_DIR}/util/testutil.cc"
        "${PROJECT_SOURCE_DIR}/util/testutil.h"

        "${bench_file}"
    )
    target_link_libraries("${bench_target_name}" leveldb)
    target_compile_definitions("${bench_target_name}"
      PRIVATE
        LEVELDB_PLATFORM_POSIX=1
    )
    if (NOT HAVE_CXX17_HAS_INCLUDE)
      target_compile_definitions("${bench_target_name}"
        PRIVATE
          LEVELDB_HAS_PORT_CONFIG_H=1
      )
    endif(NOT HAVE_CXX17_HAS_INCLUDE)
  endfunction(leveldb_benchmark)

  if(NOT BUILD_SHARED_LIBS)
    leveldb_benchmark("${PROJECT_SOURCE_DIR}/db/db_bench.cc")
  endif(NOT BUILD_SHARED_LIBS)

  check_library_exists(sqlite3 sqlite3_open "" HAVE_SQLITE3)
  if(HAVE_SQLITE3)
    leveldb_benchmark("${PROJECT_SOURCE_DIR}/doc/bench/db_bench_sqlite3.cc")
    target_link_libraries(db_bench_sqlite3 sqlite3)
  endif(HAVE_SQLITE3)

  # check_library_exists is insufficient here because the library names have
  # different manglings when compiled with clang or gcc, at least when installed
  # with Homebrew on Mac.
  set(OLD_CMAKE_REQURED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})
  list(APPEND CMAKE_REQUIRED_LIBRARIES kyotocabinet)
  check_cxx_source_compiles("
#include <kcpolydb.h>

int main() {
  kyotocabinet::TreeDB* db = new kyotocabinet::TreeDB();
  delete db;
  return 0;
}
  "  HAVE_KYOTOCABINET)
  set(CMAKE_REQUIRED_LIBRARIES ${OLD_CMAKE_REQURED_LIBRARIES})
  if(HAVE_KYOTOCABINET)
    leveldb_benchmark("${PROJECT_SOURCE_DIR}/doc/bench/db_bench_tree_db.cc")
    target_link_libraries(db_bench_tree_db kyotocabinet)
  endif(HAVE_KYOTOCABINET)
endif(LEVELDB_BUILD_BENCHMARKS)

if(LEVELDB_INSTALL)
  include(GNUInstallDirs)
  install(TARGETS leveldb
    EXPORT leveldbTargets
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
  )
  install(
    FILES
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/c.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/cache.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/comparator.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/db.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/dumpfile.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/env.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/export.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/filter_policy.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/iterator.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/options.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/slice.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/status.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/table_builder.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/table.h"
      "${PROJECT_SOURCE_DIR}/${LEVELDB_PUBLIC_INCLUDE_DIR}/write_batch.h"
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/leveldb
  )

  include(CMakePackageConfigHelpers)
  write_basic_package_version_file(
      "${PROJECT_BINARY_DIR}/leveldbConfigVersion.cmake"
      COMPATIBILITY SameMajorVersion
  )
  install(
    EXPORT leveldbTargets
    NAMESPACE leveldb::
    DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/leveldb"
  )
  install(
    FILES
      "${PROJECT_SOURCE_DIR}/cmake/leveldbConfig.cmake"
      "${PROJECT_BINARY_DIR}/leveldbConfigVersion.cmake"
    DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/leveldb"
  )
endif(LEVELDB_INSTALL)

